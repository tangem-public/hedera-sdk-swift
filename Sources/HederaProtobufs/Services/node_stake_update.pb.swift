// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: node_stake_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Updates the staking info at the end of staking period to indicate new staking period has started.
public struct Proto_NodeStakeUpdateTransactionBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Time and date of the end of the staking period that is ending
  public var endOfStakingPeriod: Proto_Timestamp {
    get {return _endOfStakingPeriod ?? Proto_Timestamp()}
    set {_endOfStakingPeriod = newValue}
  }
  /// Returns true if `endOfStakingPeriod` has been explicitly set.
  public var hasEndOfStakingPeriod: Bool {return self._endOfStakingPeriod != nil}
  /// Clears the value of `endOfStakingPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearEndOfStakingPeriod() {self._endOfStakingPeriod = nil}

  ///*
  /// Staking info of each node at the beginning of the new staking period
  public var nodeStake: [Proto_NodeStake] = []

  ///*
  /// The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day.
  public var maxStakingRewardRatePerHbar: Int64 = 0

  ///*
  /// The fraction of the network and service fees paid to the node reward account 0.0.801.
  public var nodeRewardFeeFraction: Proto_Fraction {
    get {return _nodeRewardFeeFraction ?? Proto_Fraction()}
    set {_nodeRewardFeeFraction = newValue}
  }
  /// Returns true if `nodeRewardFeeFraction` has been explicitly set.
  public var hasNodeRewardFeeFraction: Bool {return self._nodeRewardFeeFraction != nil}
  /// Clears the value of `nodeRewardFeeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearNodeRewardFeeFraction() {self._nodeRewardFeeFraction = nil}

  ///*
  /// The maximum number of trailing periods for which a user can collect rewards. For example, if this
  /// is 365 with a UTC calendar day period, then users must collect rewards at least once per calendar
  /// year to avoid missing any value.
  public var stakingPeriodsStored: Int64 = 0

  ///*
  /// The number of minutes in a staking period. Note for the special case of 1440 minutes, periods are
  /// treated as UTC calendar days, rather than repeating 1440 minute periods left-aligned at the epoch.
  public var stakingPeriod: Int64 = 0

  ///*
  /// The fraction of the network and service fees paid to the staking reward account 0.0.800.
  public var stakingRewardFeeFraction: Proto_Fraction {
    get {return _stakingRewardFeeFraction ?? Proto_Fraction()}
    set {_stakingRewardFeeFraction = newValue}
  }
  /// Returns true if `stakingRewardFeeFraction` has been explicitly set.
  public var hasStakingRewardFeeFraction: Bool {return self._stakingRewardFeeFraction != nil}
  /// Clears the value of `stakingRewardFeeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearStakingRewardFeeFraction() {self._stakingRewardFeeFraction = nil}

  ///*
  /// The minimum balance of staking reward account 0.0.800 required to active rewards.
  public var stakingStartThreshold: Int64 = 0

  ///*
  /// The total number of tinybars to be distributed as staking rewards each period.
  public var stakingRewardRate: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endOfStakingPeriod: Proto_Timestamp? = nil
  fileprivate var _nodeRewardFeeFraction: Proto_Fraction? = nil
  fileprivate var _stakingRewardFeeFraction: Proto_Fraction? = nil
}

///*
/// Staking info for each node at the end of a staking period.
public struct Proto_NodeStake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The maximum stake (rewarded or not rewarded) this node can have as consensus weight. If its stake to
  /// reward is above this maximum at the start of a period, then accounts staking to the node in that
  /// period will be rewarded at a lower rate scaled by (maxStake / stakeRewardStart).
  public var maxStake: Int64 = 0

  ///*
  /// The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight.
  /// If its total stake is below this minimum at the start of a period, then accounts staking to the node in
  /// that period will receive no rewards.
  public var minStake: Int64 = 0

  ///*
  /// The id of this node.
  public var nodeID: Int64 = 0

  ///*
  /// The reward rate _per whole hbar_ that was staked to this node with declineReward=false from the start of
  /// the staking period that is ending.
  public var rewardRate: Int64 = 0

  ///*
  /// Consensus weight of this node for the new staking period.
  public var stake: Int64 = 0

  ///*
  /// Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=true, at the
  /// beginning of the new staking period.
  public var stakeNotRewarded: Int64 = 0

  ///*
  /// Total of (balance + stakedToMe) for all accounts staked to this node with declineReward=false, at the
  /// beginning of the new staking period.
  public var stakeRewarded: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_NodeStakeUpdateTransactionBody: @unchecked Sendable {}
extension Proto_NodeStake: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_NodeStakeUpdateTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeStakeUpdateTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_of_staking_period"),
    2: .standard(proto: "node_stake"),
    3: .standard(proto: "max_staking_reward_rate_per_hbar"),
    4: .standard(proto: "node_reward_fee_fraction"),
    5: .standard(proto: "staking_periods_stored"),
    6: .standard(proto: "staking_period"),
    7: .standard(proto: "staking_reward_fee_fraction"),
    8: .standard(proto: "staking_start_threshold"),
    9: .standard(proto: "staking_reward_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endOfStakingPeriod) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodeStake) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxStakingRewardRatePerHbar) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodeRewardFeeFraction) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.stakingPeriodsStored) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.stakingPeriod) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._stakingRewardFeeFraction) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.stakingStartThreshold) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.stakingRewardRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endOfStakingPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodeStake.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeStake, fieldNumber: 2)
    }
    if self.maxStakingRewardRatePerHbar != 0 {
      try visitor.visitSingularInt64Field(value: self.maxStakingRewardRatePerHbar, fieldNumber: 3)
    }
    try { if let v = self._nodeRewardFeeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.stakingPeriodsStored != 0 {
      try visitor.visitSingularInt64Field(value: self.stakingPeriodsStored, fieldNumber: 5)
    }
    if self.stakingPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.stakingPeriod, fieldNumber: 6)
    }
    try { if let v = self._stakingRewardFeeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.stakingStartThreshold != 0 {
      try visitor.visitSingularInt64Field(value: self.stakingStartThreshold, fieldNumber: 8)
    }
    if self.stakingRewardRate != 0 {
      try visitor.visitSingularInt64Field(value: self.stakingRewardRate, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeStakeUpdateTransactionBody, rhs: Proto_NodeStakeUpdateTransactionBody) -> Bool {
    if lhs._endOfStakingPeriod != rhs._endOfStakingPeriod {return false}
    if lhs.nodeStake != rhs.nodeStake {return false}
    if lhs.maxStakingRewardRatePerHbar != rhs.maxStakingRewardRatePerHbar {return false}
    if lhs._nodeRewardFeeFraction != rhs._nodeRewardFeeFraction {return false}
    if lhs.stakingPeriodsStored != rhs.stakingPeriodsStored {return false}
    if lhs.stakingPeriod != rhs.stakingPeriod {return false}
    if lhs._stakingRewardFeeFraction != rhs._stakingRewardFeeFraction {return false}
    if lhs.stakingStartThreshold != rhs.stakingStartThreshold {return false}
    if lhs.stakingRewardRate != rhs.stakingRewardRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeStake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeStake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_stake"),
    2: .standard(proto: "min_stake"),
    3: .standard(proto: "node_id"),
    4: .standard(proto: "reward_rate"),
    5: .same(proto: "stake"),
    6: .standard(proto: "stake_not_rewarded"),
    7: .standard(proto: "stake_rewarded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxStake) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minStake) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nodeID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.rewardRate) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.stake) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.stakeNotRewarded) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.stakeRewarded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxStake != 0 {
      try visitor.visitSingularInt64Field(value: self.maxStake, fieldNumber: 1)
    }
    if self.minStake != 0 {
      try visitor.visitSingularInt64Field(value: self.minStake, fieldNumber: 2)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeID, fieldNumber: 3)
    }
    if self.rewardRate != 0 {
      try visitor.visitSingularInt64Field(value: self.rewardRate, fieldNumber: 4)
    }
    if self.stake != 0 {
      try visitor.visitSingularInt64Field(value: self.stake, fieldNumber: 5)
    }
    if self.stakeNotRewarded != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeNotRewarded, fieldNumber: 6)
    }
    if self.stakeRewarded != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeRewarded, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeStake, rhs: Proto_NodeStake) -> Bool {
    if lhs.maxStake != rhs.maxStake {return false}
    if lhs.minStake != rhs.minStake {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.rewardRate != rhs.rewardRate {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.stakeNotRewarded != rhs.stakeNotRewarded {return false}
    if lhs.stakeRewarded != rhs.stakeRewarded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
